name: build-16kb-arm64-complete

on:
  workflow_dispatch:

env:
  PYTHON_VERSION: "3.12.0"
  NDK_VERSION: "r28b"
  API_LEVEL: "24"
  TARGET_TRIPLE: "aarch64-linux-android"
  ANDROID_ABI: "arm64-v8a"
  MAKE_JOBS: "2"

jobs:
  prepare-ndk:
    runs-on: ubuntu-latest
    outputs:
      ndk-path: ${{ steps.set-ndk.outputs.ndk_path }}
    steps:
      - name: Ensure tools available
        run: sudo apt-get update && sudo apt-get install -y wget unzip

      - name: Cache NDK (runner.temp)
        id: ndk-cache
        uses: actions/cache@v4
        with:
          path: ${{ runner.temp }}/android-ndk-${{ env.NDK_VERSION }}
          key: ndk-${{ env.NDK_VERSION }}-v1
          restore-keys: |
            ndk-${{ env.NDK_VERSION }}-

      - name: If cache hit, copy NDK to HOME
        if: steps.ndk-cache.outputs.cache-hit == 'true'
        run: |
          echo "Cache hit - copying cached NDK to \$HOME"
          CACHE_DIR="${{ runner.temp }}/android-ndk-${{ env.NDK_VERSION }}"
          if [ -d "$CACHE_DIR" ]; then
            rm -rf "$HOME/android-ndk-${{ env.NDK_VERSION }}" || true
            cp -r "$CACHE_DIR" "$HOME/"
          fi
          # also record to GITHUB_OUTPUT so downstream jobs can read the output reliably
          echo "ndk_path=$HOME/android-ndk-${{ env.NDK_VERSION }}" >> $GITHUB_OUTPUT

      - name: Download NDK if cache miss
        if: steps.ndk-cache.outputs.cache-hit != 'true'
        run: |
          echo "Cache miss - downloading NDK"
          NDK_ZIP="/tmp/android-ndk-${{ env.NDK_VERSION }}-linux.zip"
          wget -q "https://dl.google.com/android/repository/android-ndk-${{ env.NDK_VERSION }}-linux.zip" -O "$NDK_ZIP"
          unzip -q "$NDK_ZIP" -d $HOME
          mkdir -p "${{ runner.temp }}/android-ndk-${{ env.NDK_VERSION }}"
          cp -r "$HOME/android-ndk-${{ env.NDK_VERSION }}" "${{ runner.temp }}/android-ndk-${{ env.NDK_VERSION }}"
          echo "ndk_path=$HOME/android-ndk-${{ env.NDK_VERSION }}" >> $GITHUB_OUTPUT

      - name: Show NDK location
        id: set-ndk
        run: |
          # final check - always set ndk_path output here (ensures job output exists)
          if [ -d "$HOME/android-ndk-${{ env.NDK_VERSION }}" ]; then
            echo "ndk_path=$HOME/android-ndk-${{ env.NDK_VERSION }}" >> $GITHUB_OUTPUT
            echo "NDK found at $HOME/android-ndk-${{ env.NDK_VERSION }}"
            ls -la "$HOME/android-ndk-${{ env.NDK_VERSION }}" | sed -n '1,120p'
          else
            echo "ERROR: NDK not found after cache/download. Directory listing:"
            ls -la $HOME || true
            exit 2
          fi

  build-host-python:
    runs-on: ubuntu-latest
    needs: prepare-ndk
    steps:
      - uses: actions/checkout@v4
      - name: Install host build deps
        run: sudo apt-get update && sudo apt-get install -y build-essential wget curl
      - name: Restore host-python cache
        id: cache-hostpython
        uses: actions/cache@v4
        with:
          path: /tmp/hostpython
          key: host-python-${{ env.PYTHON_VERSION }}-v1
          restore-keys: |
            host-python-${{ env.PYTHON_VERSION }}-
      - name: Try to download hostpython release asset (fallback)
        id: try_release
        run: |
          REPO="${{ github.repository }}"
          TAG="hostpython-v1"
          FILE="hostpython-${{ env.PYTHON_VERSION }}.tar.gz"
          URL="https://github.com/${REPO}/releases/download/${TAG}/${FILE}"
          echo "Trying release URL: $URL"
          if curl -fSL "$URL" -o /tmp/${FILE}; then
            tar -xzf /tmp/${FILE} -C /tmp || true
            echo "release_hit=true" >> $GITHUB_OUTPUT
          else
            echo "release_hit=false" >> $GITHUB_OUTPUT
          fi
      - name: Download CPython sources (if needed)
        run: |
          PY=${{ env.PYTHON_VERSION }}
          if [ ! -d "/tmp/Python-${PY}" ]; then
            wget -q "https://www.python.org/ftp/python/${PY}/Python-${PY}.tgz" -O /tmp/Python-${PY}.tgz
            tar xf /tmp/Python-${PY}.tgz -C /tmp
          fi
      - name: Build host Python (native) (skip if cached or release)
        if: steps.cache-hostpython.outputs.cache-hit != 'true' && steps.try_release.outputs.release_hit != 'true'
        run: |
          set -e
          PY=${{ env.PYTHON_VERSION }}
          pushd /tmp/Python-${PY}
          ./configure --prefix=/tmp/hostpython --enable-optimizations --without-ensurepip
          make -j${{ env.MAKE_JOBS }}
          make install
          popd
          /tmp/hostpython/bin/python3 -V
      - name: Verify host-python exists
        run: |
          if [ -x /tmp/hostpython/bin/python3 ]; then
            echo "host python ready:"
            /tmp/hostpython/bin/python3 -V
          else
            echo "host python missing; failing"
            ls -la /tmp || true
            exit 2
          fi
      - name: Upload host-python artifact (for same-run fallback)
        uses: actions/upload-artifact@v4
        with:
          name: host-python
          path: /tmp/hostpython

  build-libpython:
    runs-on: ubuntu-latest
    needs: [prepare-ndk, build-host-python]
    steps:
      - uses: actions/checkout@v4
      - name: Restore host-python cache (fast)
        id: cache-hostpython-restore
        uses: actions/cache@v4
        with:
          path: /tmp/hostpython
          key: host-python-${{ env.PYTHON_VERSION }}-v1
          restore-keys: |
            host-python-${{ env.PYTHON_VERSION }}-
      - name: Download host-python artifact (fallback if cache miss)
        if: steps.cache-hostpython-restore.outputs.cache-hit != 'true'
        uses: actions/download-artifact@v4
        with:
          name: host-python
          path: /tmp/hostpython
      - name: Inspect host-python & ensure exec
        run: |
          echo "Listing /tmp/hostpython:"
          ls -la /tmp/hostpython || true
          echo "Listing bin:"
          ls -la /tmp/hostpython/bin || true
          if [ -f /tmp/hostpython/bin/python3 ]; then
            chmod +x /tmp/hostpython/bin/python3 || true
            /tmp/hostpython/bin/python3 -V || ( echo "host python failed to run; show ldd:" && ldd /tmp/hostpython/bin/python3 || true ; exit 3)
          else
            echo "ERROR: /tmp/hostpython/bin/python3 not found after cache/artifact restore"
            exit 2
          fi
      - name: Prepare environment and ensure NDK present
        run: |
          # Try job output from prepare-ndk first, then fallback to $HOME, then runner.temp cache
          NDK="${{ needs.prepare-ndk.outputs.ndk_path }}"

          echo "Initial NDK from job output: '$NDK'"

          # If job output empty or not a dir, try default $HOME path
          if [ -z "$NDK" ] || [ ! -d "$NDK" ]; then
            if [ -d "$HOME/android-ndk-${{ env.NDK_VERSION }}" ]; then
              NDK="$HOME/android-ndk-${{ env.NDK_VERSION }}"
              echo "Falling back to \$HOME path: $NDK"
            fi
          fi

          # If still missing, check runner.temp cache (this is where prepare-ndk writes cached copy)
          if [ -z "$NDK" ] || [ ! -d "$NDK" ]; then
            CACHE_NDK="${{ runner.temp }}/android-ndk-${{ env.NDK_VERSION }}"
            if [ -d "$CACHE_NDK" ]; then
              echo "Found NDK in runner.temp cache: $CACHE_NDK"
              # copy into $HOME so Android toolchain path is stable in this job
              rm -rf "$HOME/android-ndk-${{ env.NDK_VERSION }}" || true
              cp -r "$CACHE_NDK" "$HOME/"
              NDK="$HOME/android-ndk-${{ env.NDK_VERSION }}"
              echo "Copied cached NDK -> $NDK"
            fi
          fi

          # Final check: fail with helpful debugging if not found
          if [ -z "$NDK" ] || [ ! -d "$NDK" ]; then
            echo "ERROR: NDK not found after all fallbacks."
            echo "Listing $HOME:"
            ls -la $HOME || true
            echo "Listing runner.temp:"
            ls -la "${{ runner.temp }}" || true
            exit 5
          fi

          echo "NDK used: $NDK"
          echo "ANDROID_NDK_HOME=$NDK" >> $GITHUB_ENV
          export PATH="$NDK/toolchains/llvm/prebuilt/linux-x86_64/bin:$PATH"
      - name: Download CPython sources (copy)
        run: |
          PY=${{ env.PYTHON_VERSION }}
          if [ ! -d "/tmp/Python-${PY}" ]; then
            wget -q "https://www.python.org/ftp/python/${PY}/Python-${PY}.tgz" -O /tmp/Python-${PY}.tgz
            tar xf /tmp/Python-${PY}.tgz -C /tmp
          fi
          cp -r /tmp/Python-${PY} .
      - name: Cross-compile CPython (libpython.so) with --disable-ipv6 (LD_LIBRARY_PATH set)
        shell: bash
        run: |
          set -euo pipefail
          PY=${{ env.PYTHON_VERSION }}
          # use NDK from job output if available
          NDK="${{ needs.prepare-ndk.outputs.ndk_path }}"
          if [ -z "$NDK" ] || [ ! -d "$NDK" ]; then
            NDK=$HOME/android-ndk-${{ env.NDK_VERSION }}
          fi
          API=${{ env.API_LEVEL }}
          TARGET=${{ env.TARGET_TRIPLE }}
          SYSROOT="$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot"
          cd Python-${PY}

          export CC=${TARGET}${API}-clang
          export CXX=${TARGET}${API}-clang++
          export AR=${TARGET}-ar
          export RANLIB=${TARGET}-ranlib
          export STRIP=${TARGET}-strip

          export CFLAGS="--sysroot=${SYSROOT} -D__ANDROID_API__=${API}"
          export LDFLAGS="--sysroot=${SYSROOT} -Wl,-z,max-page-size=16384 -Wl,-z,common-page-size=16384"

          export BUILD_PYTHON="/tmp/hostpython/bin/python3"
          export LD_LIBRARY_PATH="/tmp/hostpython/lib:${LD_LIBRARY_PATH:-}"

          echo "Using build python: $BUILD_PYTHON"
          $BUILD_PYTHON -V || ( echo "ERROR: build python does not run; aborting." && ldd $BUILD_PYTHON || true ; exit 5 )

          echo "CC: $CC"
          echo "SYSROOT: $SYSROOT"
          echo "CFLAGS: $CFLAGS"
          echo "LDFLAGS: $LDFLAGS"

          ./configure \
            --host=${TARGET} \
            --build=$(./config.guess) \
            --prefix=$PWD/build-arm64 \
            --enable-shared \
            --with-build-python=${BUILD_PYTHON} \
            --disable-ipv6 \
            ac_cv_file__dev_ptmx=no ac_cv_file__dev_ptc=no \
            CC="$CC" CXX="$CXX" AR="$AR" RANLIB="$RANLIB" STRIP="$STRIP" \
            CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS"

          make -j${{ env.MAKE_JOBS }}
          make install

          LIBPATH=$(find . -name "libpython*.so" | head -n1 || true)
          if [ -z "$LIBPATH" ]; then
            echo "libpython not found; failing for diagnosis"
            ls -la
            find . -maxdepth 3 -type f -name "*.so" -print || true
            exit 2
          fi
          echo "Found lib: $LIBPATH"
          cp "$LIBPATH" ../libpython-arm64.so
      - name: Upload libpython artifact
        uses: actions/upload-artifact@v4
        with:
          name: libpython-arm64
          path: libpython-arm64.so

  build-aria2:
    runs-on: ubuntu-latest
    needs: prepare-ndk
    steps:
      - uses: actions/checkout@v4
      - name: Install deps
        run: sudo apt-get update && sudo apt-get install -y build-essential cmake git autoconf automake libtool pkg-config
      - name: Prepare NDK env
        run: |
          NDK="${{ needs.prepare-ndk.outputs.ndk_path }}"
          if [ -z "$NDK" ] || [ ! -d "$NDK" ]; then
            NDK=$HOME/android-ndk-${{ env.NDK_VERSION }}
          fi
          echo "ANDROID_NDK_HOME=$NDK" >> $GITHUB_ENV
          export PATH="$NDK/toolchains/llvm/prebuilt/linux-x86_64/bin:$PATH"
      - name: Checkout aria2
        run: git clone --depth 1 https://github.com/aria2/aria2.git aria2-src
      - name: Decide build method and build or skip
        shell: bash
        run: |
          set -e
          if [ -f "aria2-src/CMakeLists.txt" ]; then
            echo "Found CMakeLists.txt — building with CMake"
            NDK="${{ needs.prepare-ndk.outputs.ndk_path }}"
            if [ -z "$NDK" ] || [ ! -d "$NDK" ]; then
              NDK=$HOME/android-ndk-${{ env.NDK_VERSION }}
            fi
            API=${{ env.API_LEVEL }}
            ABI=${{ env.ANDROID_ABI }}
            TOOLCHAIN_FILE="$NDK/build/cmake/android.toolchain.cmake"
            mkdir -p aria2-src/build && pushd aria2-src/build
            cmake .. \
              -DCMAKE_TOOLCHAIN_FILE=${TOOLCHAIN_FILE} \
              -DANDROID_ABI=${ABI} \
              -DANDROID_NATIVE_API_LEVEL=${API} \
              -DANDROID_STL=c++_shared \
              -DBUILD_SHARED_LIBS=ON \
              -DCMAKE_BUILD_TYPE=Release \
              -DCMAKE_SHARED_LINKER_FLAGS="-Wl,-z,max-page-size=16384 -Wl,-z,common-page-size=16384"
            cmake --build . -- -j${{ env.MAKE_JOBS }} || true
            LIBA=$(find . -type f -name "libaria2*.so" -o -name "libaria2c*.so" | head -n1 || true)
            if [ -n "$LIBA" ]; then
              echo "Found built library at: $LIBA"
              cp "$LIBA" ../../libaria2-arm64.so
            else
              echo "CMake completed but no libaria2 shared object found in build directories."
              echo "Listing built tree for diagnosis:"
              find . -maxdepth 4 -type f -iname "*.so" -o -iname "*.a" -o -iname "aria2*" -print || true
              echo "Creating explicit skip marker: libaria2-skip.marker"
              echo "ARIA2_SKIPPED" > libaria2-skip.marker
            fi
            popd
          else
            echo "No top-level CMakeLists.txt detected in aria2-src. Skipping automated aria2 build."
            echo "ARIA2_SKIPPED" > libaria2-skip.marker
            ls -la
          fi
      - name: Upload libaria2 artifact (if present)
        uses: actions/upload-artifact@v4
        with:
          name: libaria2-arm64
          path: |
            libaria2-arm64.so
            libaria2-skip.marker

  verify-and-package:
    runs-on: ubuntu-latest
    needs: [build-libpython, build-aria2]
    steps:
      - name: Download libpython artifact
        uses: actions/download-artifact@v4
        with:
          name: libpython-arm64
          path: .
      - name: Download libaria2 artifact (if any)
        uses: actions/download-artifact@v4
        with:
          name: libaria2-arm64
          path: .
      - name: Verify produced .so files (readelf + google check)
        run: |
          if [ -f libpython-arm64.so ]; then
            echo "=== libpython ==="
            if command -v llvm-readelf >/dev/null 2>&1; then
              llvm-readelf -l libpython-arm64.so || true
            else
              readelf -l libpython-arm64.so || true
            fi
            file libpython-arm64.so || true
          else
            echo "libpython-arm64.so not found — check earlier jobs"
          fi
          if [ -f libaria2-arm64.so ]; then
            echo "=== libaria2 ==="
            if command -v llvm-readelf >/dev/null 2>&1; then
              llvm-readelf -l libaria2-arm64.so || true
            else
              readelf -l libaria2-arm64.so || true
            fi
            file libaria2-arm64.so || true
          elif [ -f libaria2-skip.marker ]; then
            echo "aria2 build was intentionally skipped (no CMakeLists in upstream repo or no shared lib produced)."
          else
            echo "aria2 artifact not present; you can provide a prebuilt libaria2 and re-run."
          fi
          curl -s -o check_elf_alignment.sh "https://android.googlesource.com/platform/system/extras/+/refs/heads/main/tools/check_elf_alignment.sh?format=TEXT"
          base64 --decode check_elf_alignment.sh > check_elf_alignment.dec.sh && chmod +x check_elf_alignment.dec.sh
          [ -f libpython-arm64.so ] && ./check_elf_alignment.dec.sh libpython-arm64.so || true
          [ -f libaria2-arm64.so ] && ./check_elf_alignment.dec.sh libaria2-arm64.so || true
      - name: Prepare jniLibs zip
        run: |
          mkdir -p out/jniLibs/arm64-v8a
          if [ -f libpython-arm64.so ]; then
            cp libpython-arm64.so out/jniLibs/arm64-v8a/libpython.so
          fi
          if [ -f libaria2-arm64.so ]; then
            cp libaria2-arm64.so out/jniLibs/arm64-v8a/libaria2c.so || cp libaria2-arm64.so out/jniLibs/arm64-v8a/libaria2.so || true
          fi
          cd out && zip -r ../jniLibs-arm64.zip jniLibs || true
      - name: Upload final jniLibs zip
        uses: actions/upload-artifact@v4
        with:
          name: jniLibs-arm64
          path: jniLibs-arm64.zip

      # --- Auto commit & open PR: add generated files into a new branch and open PR ---
      - name: Checkout repo to commit jniLibs
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Copy jniLibs into repo workspace and detect changes
        id: copy-jni
        run: |
          BRANCH="auto/add-jniLibs-arm64-${GITHUB_RUN_ID}"
          echo "BRANCH=${BRANCH}" >> $GITHUB_ENV
          mkdir -p app/src/main/jniLibs/arm64-v8a
          if [ -f libpython-arm64.so ]; then
            cp libpython-arm64.so app/src/main/jniLibs/arm64-v8a/libpython.so
          fi
          if [ -f libaria2-arm64.so ]; then
            cp libaria2-arm64.so app/src/main/jniLibs/arm64-v8a/libaria2c.so || cp libaria2-arm64.so app/src/main/jniLibs/arm64-v8a/libaria2.so || true
          fi
          git add -A || true
          if git diff --cached --quiet; then
            echo "no_changes=true" >> $GITHUB_OUTPUT
          else
            echo "no_changes=false" >> $GITHUB_OUTPUT
          fi
      - name: Create a Pull Request with jniLibs changes (only if changed)
        if: steps.copy-jni.outputs.no_changes == 'false'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "CI: add 16KB-aligned jniLibs (arm64) from run ${{ github.run_id }}"
          branch: ${{ env.BRANCH }}
          title: "Add 16KB-aligned jniLibs (arm64) — CI run ${{ github.run_id }}"
          body: |
            This PR adds generated `jniLibs/arm64-v8a` (libpython.so and optionally libaria2c.so)
            produced by CI (16KB PT_LOAD aligned). The artifacts were built using Android NDK r28b.
            Please review and merge to include these prebuilt binaries in the app.
          labels: automatic, ci

      - name: Telegram notification (optional)
        if: always()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          if [ -n "${TELEGRAM_BOT_TOKEN:-}" ]; then
            STATUS="Workflow $GITHUB_WORKFLOW run $GITHUB_RUN_ID finished. See: $GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d chat_id="${TELEGRAM_CHAT_ID}" \
              -d text="${STATUS}"
          else
            echo "No TELEGRAM_BOT_TOKEN secret set; skipping notification."
          fi
