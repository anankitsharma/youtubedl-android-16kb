name: build-16kb-arm64-complete

on:
  workflow_dispatch:

permissions:
  contents: write

env:
  PYTHON_VERSION: "3.12.0"
  NDK_VERSION: "r28b"
  API_LEVEL: "24"
  TARGET_TRIPLE: "aarch64-linux-android"
  ANDROID_ABI: "arm64-v8a"
  MAKE_JOBS: "2"
  HOSTPY_RELEASE_TAG: "hostpython-v1"
  HOSTPY_RELEASE_ASSET: "hostpython-${{ env.PYTHON_VERSION }}.tar.gz"

jobs:
  prepare-ndk:
    name: prepare NDK
    runs-on: ubuntu-latest
    steps:
      - name: ensure tools
        run: sudo apt-get update && sudo apt-get install -y wget unzip

      - name: try cached NDK copy (runner.temp)
        id: try_ndk_cache
        run: |
          CACHE_DIR="${{ runner.temp }}/android-ndk-${{ env.NDK_VERSION }}"
          if [ -d "$CACHE_DIR" ]; then
            echo "Found cached ndk at $CACHE_DIR"
            rm -rf "$HOME/android-ndk-${{ env.NDK_VERSION }}" || true
            cp -r "$CACHE_DIR" "$HOME/"
          fi
          if [ -d "$HOME/android-ndk-${{ env.NDK_VERSION }}" ]; then
            echo "NDK_OK=true"
          else
            echo "NDK_OK=false"
          fi

      - name: download NDK if missing
        if: ${{ steps.try_ndk_cache.outputs.NDK_OK != 'true' }}
        run: |
          NDK_ZIP="/tmp/android-ndk-${{ env.NDK_VERSION }}-linux.zip"
          wget -q "https://dl.google.com/android/repository/android-ndk-${{ env.NDK_VERSION }}-linux.zip" -O "$NDK_ZIP"
          unzip -q "$NDK_ZIP" -d $HOME
          mkdir -p "${{ runner.temp }}/android-ndk-${{ env.NDK_VERSION }}"
          cp -r "$HOME/android-ndk-${{ env.NDK_VERSION }}" "${{ runner.temp }}/android-ndk-${{ env.NDK_VERSION }}"

      - name: list NDK
        run: ls -la $HOME/android-ndk-${{ env.NDK_VERSION }} || true

  build-host-python:
    name: build host python (or reuse release/cache)
    runs-on: ubuntu-latest
    needs: prepare-ndk
    steps:
      - uses: actions/checkout@v4

      - name: restore hostpython cache
        uses: actions/cache@v4
        id: hostcache
        with:
          path: /tmp/hostpython
          key: host-python-${{ env.PYTHON_VERSION }}-v1

      - name: try download hostpython release asset
        id: try_host_release
        run: |
          REPO="${{ github.repository }}"
          TAG="${{ env.HOSTPY_RELEASE_TAG }}"
          FILE="${{ env.HOSTPY_RELEASE_ASSET }}"
          URL="https://github.com/${REPO}/releases/download/${TAG}/${FILE}"
          echo "trying $URL"
          if curl -fSL "$URL" -o /tmp/${FILE}; then
            tar -xzf /tmp/${FILE} -C /tmp || true
            echo "RELEASE_HIT=true" >> $GITHUB_OUTPUT
          else
            echo "RELEASE_HIT=false" >> $GITHUB_OUTPUT
          fi

      - name: build host python if not cached/release
        if: steps.hostcache.outputs.cache-hit != 'true' && steps.try_host_release.outputs.RELEASE_HIT != 'true'
        run: |
          set -e
          PY=${{ env.PYTHON_VERSION }}
          wget -q "https://www.python.org/ftp/python/${PY}/Python-${PY}.tgz" -O /tmp/Python-${PY}.tgz
          tar xf /tmp/Python-${PY}.tgz -C /tmp
          pushd /tmp/Python-${PY}
          ./configure --prefix=/tmp/hostpython --enable-optimizations --without-ensurepip
          make -j${{ env.MAKE_JOBS }}
          make install
          popd
          /tmp/hostpython/bin/python3 -V

      - name: verify hostpython present
        run: |
          if [ -x /tmp/hostpython/bin/python3 ]; then
            /tmp/hostpython/bin/python3 -V
          else
            echo "host python missing"
            exit 2
          fi

      - name: upload host-python artifact for same-run reuse
        uses: actions/upload-artifact@v4
        with:
          name: host-python
          path: /tmp/hostpython

      - name: create release asset (optional) - upload if not present
        run: |
          REPO="${{ github.repository }}"
          TAG="${{ env.HOSTPY_RELEASE_TAG }}"
          FILE="${{ env.HOSTPY_RELEASE_ASSET }}"
          if curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${REPO}/releases/tags/${TAG}" | grep -q '"message": "Not Found"'; then
            echo "Creating release $TAG"
            curl -s -X POST -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -d "{\"tag_name\":\"${TAG}\",\"name\":\"${TAG}\",\"body\":\"Host python binary for CI reuse\"}" \
              "https://api.github.com/repos/${REPO}/releases" > /tmp/release.json
          else
            echo "Release exists"
          fi
          # upload asset if needed (safe to attempt)
          tar -czf /tmp/${FILE} -C /tmp hostpython || true
          UPLOAD_URL=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${REPO}/releases/tags/${TAG}" | jq -r .upload_url | sed -e "s/{?name,label}//" || true)
          if [ -n "$UPLOAD_URL" ]; then
            curl -s -X POST -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -H "Content-Type: application/gzip" --data-binary "@/tmp/${FILE}" "${UPLOAD_URL}?name=${FILE}" || true
          fi

  build-libpython:
    name: cross-compile libpython.so (arm64)
    runs-on: ubuntu-latest
    needs: build-host-python
    steps:
      - uses: actions/checkout@v4

      - name: restore hostpython cache (again)
        uses: actions/cache@v4
        with:
          path: /tmp/hostpython
          key: host-python-${{ env.PYTHON_VERSION }}-v1

      - name: download hostpython release if cache miss
        if: steps.cache-hostpython.outputs.cache-hit != 'true'
        run: |
          REPO="${{ github.repository }}"
          TAG="${{ env.HOSTPY_RELEASE_TAG }}"
          FILE="${{ env.HOSTPY_RELEASE_ASSET }}"
          URL="https://github.com/${REPO}/releases/download/${TAG}/${FILE}"
          if curl -fSL "$URL" -o /tmp/${FILE}; then
            tar -xzf /tmp/${FILE} -C /tmp || true
          fi

      - name: download hostpython artifact (same-run fallback)
        if: success()
        uses: actions/download-artifact@v4
        with:
          name: host-python
          path: /tmp/hostpython

      - name: ensure hostpython executable
        run: |
          ls -la /tmp/hostpython || true
          if [ -f /tmp/hostpython/bin/python3 ]; then
            chmod +x /tmp/hostpython/bin/python3 || true
            /tmp/hostpython/bin/python3 -V || true
          fi

      - name: prepare NDK path
        run: |
          if [ -d "$HOME/android-ndk-${{ env.NDK_VERSION }}" ]; then
            echo "Using $HOME/android-ndk-${{ env.NDK_VERSION }}"
            echo "ANDROID_NDK_HOME=$HOME/android-ndk-${{ env.NDK_VERSION }}" >> $GITHUB_ENV
          else
            echo "NDK missing"
            exit 5
          fi
      - name: download CPython sources
        run: |
          PY=${{ env.PYTHON_VERSION }}
          if [ ! -d "/tmp/Python-${PY}" ]; then
            wget -q "https://www.python.org/ftp/python/${PY}/Python-${PY}.tgz" -O /tmp/Python-${PY}.tgz
            tar xf /tmp/Python-${PY}.tgz -C /tmp
          fi
          cp -r /tmp/Python-${PY} .
      - name: cross-compile libpython
        shell: bash
        run: |
          set -euo pipefail
          PY=${{ env.PYTHON_VERSION }}
          NDK="$HOME/android-ndk-${{ env.NDK_VERSION }}"
          API=${{ env.API_LEVEL }}
          TARGET=${{ env.TARGET_TRIPLE }}
          SYSROOT="$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot"
          cd Python-${PY}
          export CC=${TARGET}${API}-clang
          export CXX=${TARGET}${API}-clang++
          export AR=${TARGET}-ar
          export RANLIB=${TARGET}-ranlib
          export STRIP=${TARGET}-strip
          export CFLAGS="--sysroot=${SYSROOT} -D__ANDROID_API__=${API}"
          export LDFLAGS="--sysroot=${SYSROOT} -Wl,-z,max-page-size=16384 -Wl,-z,common-page-size=16384"
          export BUILD_PYTHON="/tmp/hostpython/bin/python3"
          export LD_LIBRARY_PATH="/tmp/hostpython/lib:${LD_LIBRARY_PATH:-}"
          $BUILD_PYTHON -V || true
          ./configure \
            --host=${TARGET} \
            --build=$(./config.guess) \
            --prefix=$PWD/build-arm64 \
            --enable-shared \
            --with-build-python=${BUILD_PYTHON} \
            --disable-ipv6 \
            ac_cv_file__dev_ptmx=no ac_cv_file__dev_ptc=no \
            CC="$CC" CXX="$CXX" AR="$AR" RANLIB="$RANLIB" STRIP="$STRIP" \
            CFLAGS="$CFLAGS" LDFLAGS="$LDFLAGS"
          make -j${{ env.MAKE_JOBS }} || true
          make install || true
          LIBPATH=$(find . -name "libpython*.so" | head -n1 || true)
          if [ -z "$LIBPATH" ]; then
            echo "libpython not found; failing"
            exit 2
          fi
          cp "$LIBPATH" ../libpython-arm64.so
      - name: upload libpython artifact
        uses: actions/upload-artifact@v4
        with:
          name: libpython-arm64
          path: libpython-arm64.so

  build-aria2:
    name: try build aria2
    runs-on: ubuntu-latest
    needs: prepare-ndk
    steps:
      - uses: actions/checkout@v4
      - name: install deps
        run: sudo apt-get update && sudo apt-get install -y build-essential cmake git autoconf automake libtool pkg-config
      - name: checkout aria2
        run: git clone --depth 1 https://github.com/aria2/aria2.git aria2-src
      - name: attempt build or skip
        shell: bash
        run: |
          if [ -f "aria2-src/CMakeLists.txt" ]; then
            NDK="$HOME/android-ndk-${{ env.NDK_VERSION }}"
            TOOLCHAIN_FILE="$NDK/build/cmake/android.toolchain.cmake"
            mkdir -p aria2-src/build && pushd aria2-src/build
            cmake .. -DCMAKE_TOOLCHAIN_FILE=${TOOLCHAIN_FILE} -DANDROID_ABI=${{ env.ANDROID_ABI }} -DANDROID_NATIVE_API_LEVEL=${{ env.API_LEVEL }} -DANDROID_STL=c++_shared -DBUILD_SHARED_LIBS=ON -DCMAKE_BUILD_TYPE=Release -DCMAKE_SHARED_LINKER_FLAGS="-Wl,-z,max-page-size=16384 -Wl,-z,common-page-size=16384"
            cmake --build . -- -j${{ env.MAKE_JOBS }} || true
            LIBA=$(find . -type f -name "libaria2*.so" -o -name "libaria2c*.so" | head -n1 || true)
            if [ -n "$LIBA" ]; then
              cp "$LIBA" ../../libaria2-arm64.so
            else
              echo "No lib created by aria2 build"
            fi
            popd
          else
            echo "No top-level CMakeLists.txt - skipping aria2 build"
            echo "ARIA2_SKIPPED" > libaria2-skip.marker
          fi
      - uses: actions/upload-artifact@v4
        with:
          name: libaria2-arm64
          path: |
            libaria2-arm64.so
            libaria2-skip.marker

  verify-and-package:
    name: verify and package
    runs-on: ubuntu-latest
    needs: [build-libpython, build-aria2]
    steps:
      - name: download libpython
        uses: actions/download-artifact@v4
        with:
          name: libpython-arm64
          path: .
      - name: download aria2 artifact
        uses: actions/download-artifact@v4
        with:
          name: libaria2-arm64
          path: .
      - name: check produced files
        run: |
          [ -f libpython-arm64.so ] && echo "libpython ok" || echo "libpython missing"
          [ -f libaria2-arm64.so ] && echo "libaria2 ok" || echo "libaria2 missing or skipped"
          [ -f libaria2-skip.marker ] && echo "aria2 was skipped (marker present)"
      - name: prepare jniLibs zip
        run: |
          mkdir -p out/jniLibs/arm64-v8a
          [ -f libpython-arm64.so ] && cp libpython-arm64.so out/jniLibs/arm64-v8a/libpython.so || true
          [ -f libaria2-arm64.so ] && cp libaria2-arm64.so out/jniLibs/arm64-v8a/libaria2c.so || true
          cd out && zip -r ../jniLibs-arm64.zip jniLibs || true
      - name: upload jniLibs zip
        uses: actions/upload-artifact@v4
        with:
          name: jniLibs-arm64
          path: jniLibs-arm64.zip
      - name: create PR with jniLibs (if present)
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "CI: add jniLibs arm64 from run ${{ github.run_id }}"
          branch: "auto/add-jniLibs-arm64-${{ github.run_id }}"
          title: "Add jniLibs arm64 (CI)"
          body: "Add generated jniLibs/arm64-v8a"
          labels: automatic,ci
          paths: |
            out/jniLibs/**

