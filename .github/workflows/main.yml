name: Build aligned native libs (16KB)

on:
  workflow_dispatch:

# Allow multiple runs; we prefer reliability over cancellation
concurrency:
  group: 16kb-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build-ffmpeg:
    name: Build FFmpeg (arm64, direct NDK)
    runs-on: ubuntu-latest
    timeout-minutes: 240
    if: false
    env:
      API: 21
      EXTRA_LDFLAGS: "-Wl,-z,max-page-size=16384 -Wl,-z,common-page-size=16384"
      CCACHE_DIR: ${{ github.workspace }}/.ccache
    steps:
      - uses: actions/checkout@v4

      - name: Install deps
        run: |
          sudo apt-get update
          sudo apt-get install -y curl tar xz-utils pkg-config build-essential git nasm yasm llvm ccache

      - name: Set up Java (for sdkmanager)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      - name: Install Android NDK r27
        run: |
          yes | sdkmanager --licenses >/dev/null || true
          sdkmanager --install "ndk;27.0.12077973" "platform-tools" "platforms;android-34" || true
          echo "ANDROID_NDK=$ANDROID_SDK_ROOT/ndk/27.0.12077973" >> $GITHUB_ENV
          echo "ANDROID_NDK_ROOT=$ANDROID_SDK_ROOT/ndk/27.0.12077973" >> $GITHUB_ENV

      - name: Restore ccache
        uses: actions/cache@v4
        with:
          path: .ccache
          key: ffmpeg-ccache-${{ runner.os }}-${{ hashFiles('.github/workflows/main.yml') }}
          restore-keys: |
            ffmpeg-ccache-${{ runner.os }}-

      - name: Download FFmpeg source (shallow)
        run: |
          curl -L -o ffmpeg.tar.xz https://ffmpeg.org/releases/ffmpeg-6.1.1.tar.xz
          mkdir ffmpeg-src && tar -xf ffmpeg.tar.xz -C ffmpeg-src --strip-components=1

      - name: Configure (aarch64, minimal, shared)
        working-directory: ffmpeg-src
        env:
          ANDROID_NDK: ${{ env.ANDROID_NDK }}
        run: |
          export NDK=${ANDROID_NDK:-$ANDROID_NDK_ROOT}
          export TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64
          export TARGET=aarch64-linux-android
          export API=${API}
          export CC="$TOOLCHAIN/bin/${TARGET}${API}-clang"
          export CXX="$TOOLCHAIN/bin/${TARGET}${API}-clang++"
          export AR=$TOOLCHAIN/bin/llvm-ar
          export LD=$TOOLCHAIN/bin/ld.lld
          export STRIP=$TOOLCHAIN/bin/llvm-strip
          export NM=$TOOLCHAIN/bin/llvm-nm
          export RANLIB=$TOOLCHAIN/bin/llvm-ranlib
          export PKG_CONFIG=false
          export CFLAGS="-fPIC -O2"
          export LDFLAGS="${LDFLAGS:-} ${EXTRA_LDFLAGS}"
          ./configure \
            --target-os=android \
            --arch=aarch64 \
            --enable-cross-compile \
            --cc="$CC" \
            --cxx="$CXX" \
            --ar="$AR" \
            --nm="$NM" \
            --ranlib="$RANLIB" \
            --strip="$STRIP" \
            --pkg-config=false \
            --prefix=/data/youtubedl-android/usr \
            --enable-shared \
            --disable-static \
            --disable-doc \
            --disable-debug \
            --enable-small \
            --disable-autodetect \
            --enable-ffmpeg \
            --enable-ffprobe \
            --disable-ffplay \
            --disable-postproc \
            --disable-avdevice \
            --disable-filters \
            --disable-network \
            --disable-muxers \
            --disable-encoders \
            --disable-decoders \
            --disable-demuxers \
            --disable-parsers \
            --enable-muxer=mp4,matroska,webm,segment,concat,adts \
            --enable-demuxer=mov,matroska,webm,mp3,mp4,ogg,flv,mpegts \
            --enable-parser=aac,h264,hevc,opus,vorbis,mp3 \
            --enable-decoder=aac,h264,hevc,opus,vorbis,mp3 \
            --enable-protocol=file,pipe,concat

      - name: Build
        working-directory: ffmpeg-src
        run: |
          make -j$(nproc)
          make install DESTDIR=$GITHUB_WORKSPACE/out/ffmpeg-install || true

      - name: Stage outputs
        run: |
          mkdir -p out/jniLibs/arm64-v8a
          # Package installed libs similar to Termux structure for yt-dlp wrapper
          if [ -d out/ffmpeg-install/data/youtubedl-android/usr ]; then
            (cd out/ffmpeg-install && zip --symlinks -r $GITHUB_WORKSPACE/out/libffmpeg.zip data/youtubedl-android/usr)
            cp $GITHUB_WORKSPACE/out/libffmpeg.zip out/jniLibs/arm64-v8a/libffmpeg.zip.so
          fi
          # Ship executables as .so (matches existing packaging convention)
          if [ -f ffmpeg-src/ffmpeg ]; then cp ffmpeg-src/ffmpeg out/jniLibs/arm64-v8a/libffmpeg.so; fi
          if [ -f ffmpeg-src/ffprobe ]; then cp ffmpeg-src/ffprobe out/jniLibs/arm64-v8a/libffprobe.so; fi

      - name: Upload FFmpeg artifact
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-arm64
          path: out/jniLibs/arm64-v8a
          if-no-files-found: error

  build-aria2:
    name: Build aria2 (arm64)
    runs-on: ubuntu-latest
    timeout-minutes: 360
    env:
      TERMUX_ARCH: aarch64
      TERMUX_PREFIX: /data/youtubedl-android/usr
      TERMUX_ANDROID_HOME: /data/youtubedl-android/home
      MAKEFLAGS: "-j$(nproc)"
      EXTRA_LDFLAGS: "-Wl,-z,max-page-size=16384 -Wl,-z,common-page-size=16384"
    steps:
      - uses: actions/checkout@v4

      - name: Install deps
        run: |
          sudo apt-get update
          sudo apt-get install -y zip unzip dpkg-dev binutils llvm
          docker --version || true

      - name: Restore caches
        uses: actions/cache@v4
        with:
          path: |
            termux-packages/.termux-build
            termux-packages/debs
            termux-packages/.cache
          key: aria2-${{ runner.os }}-${{ hashFiles('.github/workflows/main.yml') }}
          restore-keys: |
            aria2-${{ runner.os }}-

      - name: Clone Termux packages (shallow)
        run: |
          if [ ! -d termux-packages ]; then
            git clone --depth 1 https://github.com/termux/termux-packages.git
          fi

      - name: Build aria2
        working-directory: termux-packages
        run: |
          cat > build-aria2.sh << 'EOS'
          #!/usr/bin/env bash
          set -euxo pipefail
          export TERMUX_ARCH=${TERMUX_ARCH}
          export TERMUX_PREFIX=${TERMUX_PREFIX}
          export TERMUX_ANDROID_HOME=${TERMUX_ANDROID_HOME}
          export MAKEFLAGS=${MAKEFLAGS}
          export LDFLAGS="${LDFLAGS:-} ${EXTRA_LDFLAGS}"
          ./scripts/run-docker.sh env TERMUX_ARCH=${TERMUX_ARCH} LDFLAGS="${LDFLAGS}" ./build-package.sh aria2
          EOS
          chmod +x build-aria2.sh
          ./build-aria2.sh

      - name: List built aria2 debs
        run: |
          echo "Listing debs after aria2 build:"
          ls -la termux-packages/debs || true

      - name: Stage aria2 outputs
        run: |
          find termux-packages/debs -type f -name "*.deb" -print -exec dpkg-deb -x {} $GITHUB_WORKSPACE/out/aria2 \; || true
          cd $GITHUB_WORKSPACE/out/aria2 || exit 0
          mkdir -p $GITHUB_WORKSPACE/lib/arm64-v8a
          aria2c_path=$(find data -type f -name aria2c 2>/dev/null | head -n1 || true)
          [ -n "$aria2c_path" ] && cp "$aria2c_path" $GITHUB_WORKSPACE/lib/arm64-v8a/libaria2c.so || true

      - name: Upload aria2 artifact
        uses: actions/upload-artifact@v4
        with:
          name: aria2-arm64
          path: lib/arm64-v8a
          if-no-files-found: error

  build-python:
    name: Build Python (arm64)
    runs-on: ubuntu-latest
    timeout-minutes: 360
    env:
      TERMUX_ARCH: aarch64
      TERMUX_PREFIX: /data/youtubedl-android/usr
      TERMUX_ANDROID_HOME: /data/youtubedl-android/home
      MAKEFLAGS: "-j$(nproc)"
      EXTRA_LDFLAGS: "-Wl,-z,max-page-size=16384 -Wl,-z,common-page-size=16384"
    steps:
      - uses: actions/checkout@v4

      - name: Install deps
        run: |
          sudo apt-get update
          sudo apt-get install -y zip unzip dpkg-dev binutils llvm
          docker --version || true

      - name: Restore caches
        uses: actions/cache@v4
        with:
          path: |
            termux-packages/.termux-build
            termux-packages/debs
            termux-packages/.cache
          key: python-${{ runner.os }}-${{ hashFiles('.github/workflows/main.yml') }}
          restore-keys: |
            python-${{ runner.os }}-

      - name: Clone Termux packages (shallow)
        run: |
          if [ ! -d termux-packages ]; then
            git clone --depth 1 https://github.com/termux/termux-packages.git
          fi

      - name: Build Python
        working-directory: termux-packages
        run: |
          cat > build-python.sh << 'EOS'
          #!/usr/bin/env bash
          set -euxo pipefail
          export TERMUX_ARCH=${TERMUX_ARCH}
          export TERMUX_PREFIX=${TERMUX_PREFIX}
          export TERMUX_ANDROID_HOME=${TERMUX_ANDROID_HOME}
          export MAKEFLAGS=${MAKEFLAGS}
          export LDFLAGS="${LDFLAGS:-} ${EXTRA_LDFLAGS}"
          ./scripts/run-docker.sh env TERMUX_ARCH=${TERMUX_ARCH} LDFLAGS="${LDFLAGS}" ./build-package.sh python
          EOS
          chmod +x build-python.sh
          ./build-python.sh

      - name: List built Python debs
        run: |
          echo "Listing debs after Python build:"
          ls -la termux-packages/debs || true

      - name: Stage Python outputs
        run: |
          find termux-packages/debs -type f -name "*.deb" -print -exec dpkg-deb -x {} $GITHUB_WORKSPACE/out/python \; || true
          cd $GITHUB_WORKSPACE/out/python || exit 0
          mkdir -p $GITHUB_WORKSPACE/lib/arm64-v8a
          lp=$(find data/youtubedl-android/usr/lib -maxdepth 1 -type f -name "libpython*.so" | head -n1 || true)
          [ -n "$lp" ] && cp "$lp" $GITHUB_WORKSPACE/lib/arm64-v8a/libpython.so || true

      - name: Upload Python artifact
        uses: actions/upload-artifact@v4
        with:
          name: python-arm64
          path: lib/arm64-v8a
          if-no-files-found: error

  verify-and-bundle:
    name: Verify alignment and bundle
    runs-on: ubuntu-latest
    needs: [build-aria2, build-python]
    if: ${{ always() }}
    timeout-minutes: 60
    steps:
      - uses: actions/checkout@v4

      - name: Install verification tools
        run: |
          sudo apt-get update
          sudo apt-get install -y llvm-14 llvm-14-tools binutils
          # Verify installation and create symlinks
          echo "Available llvm tools:"
          ls -la /usr/bin/llvm* | head -10 || true
          # Create symlinks for llvm-readobj if needed
          if ! command -v llvm-readobj &> /dev/null; then
            if [ -f /usr/bin/llvm-readobj-14 ]; then
              sudo ln -sf /usr/bin/llvm-readobj-14 /usr/bin/llvm-readobj
              echo "Created symlink for llvm-readobj"
            else
              echo "llvm-readobj-14 not found, trying alternative installation"
              sudo apt-get install -y llvm-tools-14 || sudo apt-get install -y llvm-tools
            fi
          fi
          # Verify llvm-readobj is available
          if command -v llvm-readobj &> /dev/null; then
            echo "✅ llvm-readobj is available: $(which llvm-readobj)"
            llvm-readobj --version || true
          else
            echo "⚠️ llvm-readobj still not available, will use readelf fallback"
          fi

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: _artifacts

      - name: Merge outputs
        run: |
          mkdir -p lib/arm64-v8a
          find _artifacts -type f -name "*.so" -exec cp {} lib/arm64-v8a/ \; || true

      - name: Verify 16KB alignment (PT_LOAD only)
        run: |
          set -euxo pipefail
          shopt -s nullglob
          files=(lib/arm64-v8a/*.so)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No .so files found to verify" && exit 1
          fi
          echo "Found ${#files[@]} .so files to verify:"
          printf '%s\n' "${files[@]}"
          
          # Filter out ZIP files (they have .zip.so extension but are actually ZIP archives)
          elf_files=()
          zip_files=()
          for f in "${files[@]}"; do
            if file "$f" | grep -q "Zip archive"; then
              zip_files+=("$f")
              echo "📦 Skipping ZIP file: $f"
            else
              elf_files+=("$f")
            fi
          done
          
          echo "Found ${#elf_files[@]} ELF files to verify:"
          printf '%s\n' "${elf_files[@]}"
          echo "Found ${#zip_files[@]} ZIP files (skipped):"
          printf '%s\n' "${zip_files[@]}"
          
          if [ ${#elf_files[@]} -eq 0 ]; then
            echo "No ELF files found to verify" && exit 1
          fi
          
          fail=0
          
          # Check if llvm-readobj is available
          if command -v llvm-readobj &> /dev/null; then
            echo "Using llvm-readobj for verification"
            for f in "${elf_files[@]}"; do
              echo "Checking $f"
              # Print PT_LOAD headers for debugging
              if llvm-readobj --program-headers "$f" 2>/dev/null | grep -E "(Type: PT_LOAD|Alignment:)" || true; then
                # Require at least one PT_LOAD with Alignment: 16384
                if llvm-readobj --program-headers "$f" 2>/dev/null | awk '/Type: PT_LOAD/{flag=1} flag && /Alignment:/{print $2; flag=0}' | grep -q 16384; then
                  echo "✅ Alignment check passed for $f"
                else
                  echo "❌ Alignment check failed for $f - no PT_LOAD segment with 16384 alignment found"
                  fail=1
                fi
              else
                echo "⚠️ llvm-readobj failed for $f, falling back to readelf"
                # Fallback to readelf for this file
                if readelf -l "$f" 2>/dev/null | grep -q "LOAD.*0x4000"; then
                  echo "✅ Alignment check passed for $f (16KB alignment detected via readelf)"
                else
                  echo "❌ Alignment check failed for $f - no 16KB alignment found"
                  readelf -l "$f" | grep "LOAD" || true
                  fail=1
                fi
              fi
            done
          else
            echo "⚠️ llvm-readobj not available, using readelf as fallback"
            for f in "${elf_files[@]}"; do
              echo "Checking $f with readelf"
              # Use readelf as fallback - check for 16KB alignment in program headers
              if readelf -l "$f" 2>/dev/null | grep -q "LOAD.*0x4000"; then
                echo "✅ Alignment check passed for $f (16KB alignment detected)"
              else
                echo "❌ Alignment check failed for $f - no 16KB alignment found"
                readelf -l "$f" | grep "LOAD" || true
                fail=1
              fi
            done
          fi
          
          if [ $fail -eq 0 ]; then
            echo "🎉 All native libraries have 16KB alignment!"
            if [ ${#zip_files[@]} -gt 0 ]; then
              echo "📦 Note: ${#zip_files[@]} ZIP files were skipped (they contain libraries but are not ELF binaries)"
            fi
          else
            echo "💥 Some native libraries failed 16KB alignment check"
          fi
          exit $fail

      - name: Upload bundled artifacts
        uses: actions/upload-artifact@v4
        with:
          name: aligned-jniLibs-arm64-v8a
          path: lib/arm64-v8a
