name: Stage drop-in jniLibs (16KB)

on:
  workflow_dispatch:
    inputs:
      reuse_run_id:
        description: "Run ID to reuse artifacts from (same repo)"
        required: true
        type: string
      aria2_artifact:
        description: "Name of staged aria2 ZIP artifact"
        required: false
        default: "aria2-arm64"
        type: string
      python_artifact:
        description: "Name of staged Python ZIP artifact"
        required: false
        default: "python-arm64"
        type: string
      aria2_debs_artifact:
        description: "Name of aria2 debs artifact"
        required: false
        default: "aria2-debs"
        type: string
      python_debs_artifact:
        description: "Name of Python debs artifact"
        required: false
        default: "python-debs"
        type: string

jobs:
  stage-jniLibs:
    name: Assemble ready-to-drop jniLibs
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev llvm zip unzip
          gh --version || true

      - name: Download staged aria2 ZIP
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: ${{ inputs.aria2_artifact }}
          path: _aria2_zip
          run-id: ${{ inputs.reuse_run_id }}

      - name: Download staged Python ZIP
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: ${{ inputs.python_artifact }}
          path: _python_zip
          run-id: ${{ inputs.reuse_run_id }}

      - name: Download aria2 debs
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: ${{ inputs.aria2_debs_artifact }}
          path: _aria2_debs
          run-id: ${{ inputs.reuse_run_id }}

      - name: Fallback download aria2 debs by pattern
        if: ${{ always() }}
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: aria2-*
          path: _aria2_debs
          merge-multiple: true
          run-id: ${{ inputs.reuse_run_id }}

      - name: Fallback download artifacts via gh (aria2)
        if: ${{ always() }}
        run: |
          set -euxo pipefail
          mkdir -p _aria2_debs _aria2_zip
          # If no debs present yet, try gh run download
          if [ -z "$(ls -1 _aria2_debs 2>/dev/null || true)" ]; then
            gh run download ${{ inputs.reuse_run_id }} -n ${{ inputs.aria2_debs_artifact }} -D _aria2_debs || true
          fi
          # Try staged zip as well
          if [ ! -f _aria2_zip/libaria2c.zip ]; then
            gh run download ${{ inputs.reuse_run_id }} -n ${{ inputs.aria2_artifact }} -D _aria2_zip || true
          fi

      - name: Download Python debs
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: ${{ inputs.python_debs_artifact }}
          path: _python_debs
          run-id: ${{ inputs.reuse_run_id }}

      - name: Fallback download Python debs by pattern
        if: ${{ always() }}
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: python-*
          path: _python_debs
          merge-multiple: true
          run-id: ${{ inputs.reuse_run_id }}

      - name: Fallback download artifacts via gh (python)
        if: ${{ always() }}
        run: |
          set -euxo pipefail
          mkdir -p _python_debs _python_zip
          if [ -z "$(ls -1 _python_debs 2>/dev/null || true)" ]; then
            gh run download ${{ inputs.reuse_run_id }} -n ${{ inputs.python_debs_artifact }} -D _python_debs || true
          fi
          if [ ! -f _python_zip/libpython.zip ]; then
            gh run download ${{ inputs.reuse_run_id }} -n ${{ inputs.python_artifact }} -D _python_zip || true
          fi

      - name: Extract debs and assemble jniLibs
        run: |
          set -euxo pipefail
          mkdir -p out/jniLibs/arm64-v8a out/tmp/aria2 out/tmp/python

          # Extract debs into temporary roots
          shopt -s nullglob
          for f in _aria2_debs/*.deb; do dpkg-deb -x "$f" out/tmp/aria2 || true; done
          for f in _python_debs/*.deb; do dpkg-deb -x "$f" out/tmp/python || true; done

          # Determine prefixes for aria2 and python
          aria2_prefix=""
          for p in out/tmp/aria2/data/youtubedl-android/usr out/tmp/aria2/data/data/com.termux/files/usr out/tmp/aria2/data/usr out/tmp/aria2/usr; do
            if [ -d "$p/lib" ]; then aria2_prefix="$p"; break; fi
          done
          python_prefix=""
          for p in out/tmp/python/data/youtubedl-android/usr out/tmp/python/data/data/com.termux/files/usr out/tmp/python/data/usr out/tmp/python/usr; do
            if [ -d "$p/lib" ]; then python_prefix="$p"; break; fi
          done

          # Stage .zip.so payloads, prefer repo outputfiles/, then staged zips, else build from debs
          aria2_zip_repo=$(find "$GITHUB_WORKSPACE/outputfiles" -type f -name libaria2c.zip -print -quit || true)
          if [ -n "$aria2_zip_repo" ]; then
            cp "$aria2_zip_repo" out/jniLibs/arm64-v8a/libaria2c.zip.so
          elif [ -f _aria2_zip/libaria2c.zip ]; then
            cp _aria2_zip/libaria2c.zip out/jniLibs/arm64-v8a/libaria2c.zip.so
          else
            if [ -z "$aria2_prefix" ]; then echo "::error::Could not find aria2 prefix to build zip"; exit 1; fi
            (cd "$(dirname "$aria2_prefix")" && zip --symlinks -r "$GITHUB_WORKSPACE/out/jniLibs/arm64-v8a/libaria2c.zip.so" "$(basename "$aria2_prefix")"/lib)
          fi

          python_zip_repo=$(find "$GITHUB_WORKSPACE/outputfiles" -type f -name libpython.zip -print -quit || true)
          if [ -n "$python_zip_repo" ]; then
            cp "$python_zip_repo" out/jniLibs/arm64-v8a/libpython.zip.so
          elif [ -f _python_zip/libpython.zip ]; then
            cp _python_zip/libpython.zip out/jniLibs/arm64-v8a/libpython.zip.so
          else
            if [ -z "$python_prefix" ]; then echo "::error::Could not find python prefix to build zip"; exit 1; fi
            (cd "$(dirname "$python_prefix")" && zip --symlinks -r "$GITHUB_WORKSPACE/out/jniLibs/arm64-v8a/libpython.zip.so" "$(basename "$python_prefix")"/lib)
          fi

          # Find aria2c executable and rename to libaria2c.so
          aria2c_path=$(find out/tmp/aria2 -type f -name aria2c | head -n1 || true)
          if [ -z "$aria2c_path" ]; then
            echo "::error::aria2c not found in aria2 debs"; exit 1
          fi
          cp "$aria2c_path" out/jniLibs/arm64-v8a/libaria2c.so

          # Find versioned libpythonX.Y.so and rename to libpython.so
          pyso_path=$(find out/tmp/python -type f -path "*/usr/lib/*" -name "libpython*.so" | head -n1 || true)
          if [ -z "$pyso_path" ]; then
            echo "::error::libpython*.so not found in python debs"; exit 1
          fi
          cp "$pyso_path" out/jniLibs/arm64-v8a/libpython.so

      - name: Verify 16KB PT_LOAD alignment
        run: |
          set -euo pipefail
          for f in out/jniLibs/arm64-v8a/*.so; do
            echo "Checking $f"
            if ! llvm-readobj --program-headers "$f" | grep -A3 "Type: PT_LOAD" | grep -q "Alignment: 16384"; then
              echo "::error::$f missing PT_LOAD Alignment: 16384"; exit 1
            fi
          done

      - name: Upload jniLibs artifact
        uses: actions/upload-artifact@v4
        with:
          name: jniLibs-arm64
          path: out/jniLibs/arm64-v8a
          if-no-files-found: error
          retention-days: 14


