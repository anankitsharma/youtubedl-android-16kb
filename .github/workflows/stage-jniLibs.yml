name: Stage drop-in jniLibs (16KB)

on:
  workflow_dispatch:
    inputs:
      reuse_run_id:
        description: "Run ID to reuse artifacts from (same repo)"
        required: true
        type: string
      aria2_artifact:
        description: "Name of staged aria2 ZIP artifact"
        required: false
        default: "aria2-arm64"
        type: string
      python_artifact:
        description: "Name of staged Python ZIP artifact"
        required: false
        default: "python-arm64"
        type: string
      aria2_debs_artifact:
        description: "Name of aria2 debs artifact"
        required: false
        default: "aria2-debs"
        type: string
      python_debs_artifact:
        description: "Name of Python debs artifact"
        required: false
        default: "python-debs"
        type: string

jobs:
  stage-jniLibs:
    name: Assemble ready-to-drop jniLibs
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev llvm zip unzip
          gh --version || true

      - name: List artifacts in source run
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euxo pipefail
          echo "Listing artifacts for run: ${{ inputs.reuse_run_id }} in ${{ github.repository }}"
          gh api repos/${{ github.repository }}/actions/runs/${{ inputs.reuse_run_id }}/artifacts --paginate -q '.artifacts[] | .name + " (id:" + (.id|tostring) + ")"' || true

      - name: Download staged aria2 ZIP
        uses: actions/download-artifact@v5
        continue-on-error: true
        with:
          name: ${{ inputs.aria2_artifact }}
          path: _aria2_zip
          run-id: ${{ inputs.reuse_run_id }}
          github-token: ${{ github.token }}

      - name: Download staged Python ZIP
        uses: actions/download-artifact@v5
        continue-on-error: true
        with:
          name: ${{ inputs.python_artifact }}
          path: _python_zip
          run-id: ${{ inputs.reuse_run_id }}
          github-token: ${{ github.token }}

      - name: Download aria2 debs
        uses: actions/download-artifact@v5
        continue-on-error: true
        with:
          name: ${{ inputs.aria2_debs_artifact }}
          path: _aria2_debs
          run-id: ${{ inputs.reuse_run_id }}
          github-token: ${{ github.token }}

      - name: Fallback download aria2 debs by pattern
        if: ${{ always() }}
        uses: actions/download-artifact@v5
        continue-on-error: true
        with:
          pattern: aria2-*
          path: _aria2_debs
          merge-multiple: true
          run-id: ${{ inputs.reuse_run_id }}
          github-token: ${{ github.token }}

      - name: Fallback download artifacts via gh (aria2)
        if: ${{ always() }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euxo pipefail
          mkdir -p _aria2_debs _aria2_zip
          # If no debs present yet, try gh run download
          if [ -z "$(ls -1 _aria2_debs 2>/dev/null || true)" ]; then
            gh run download ${{ inputs.reuse_run_id }} -n ${{ inputs.aria2_debs_artifact }} -D _aria2_debs || true
          fi
          # Try staged zip as well
          if [ ! -f _aria2_zip/libaria2c.zip ]; then
            gh run download ${{ inputs.reuse_run_id }} -n ${{ inputs.aria2_artifact }} -D _aria2_zip || true
          fi

      - name: Fallback download ALL artifacts (any name)
        if: ${{ always() }}
        uses: actions/download-artifact@v5
        continue-on-error: true
        with:
          pattern: "*"
          path: _all_artifacts
          merge-multiple: true
          run-id: ${{ inputs.reuse_run_id }}
          github-token: ${{ github.token }}

      - name: Consolidate debs from any downloaded artifacts
        if: ${{ always() }}
        run: |
          set -euxo pipefail
          mkdir -p _aria2_debs _python_debs
          if [ -d _all_artifacts ]; then
            # Copy potential debs into expected folders based on filename hints
            while IFS= read -r -d '' f; do
              base=$(basename "$f")
              if echo "$base" | grep -qi aria2; then
                cp -n "$f" _aria2_debs/ || true
              fi
              if echo "$base" | grep -qi python; then
                cp -n "$f" _python_debs/ || true
              fi
            done < <(find _all_artifacts -type f -name "*.deb" -print0)
            # Also bring over staged zips if present
            if [ ! -f _aria2_zip/libaria2c.zip ]; then
              azip=$(find _all_artifacts -type f -name libaria2c.zip -print -quit || true)
              if [ -n "$azip" ]; then mkdir -p _aria2_zip && cp "$azip" _aria2_zip/libaria2c.zip; fi
            fi
            if [ ! -f _python_zip/libpython.zip ]; then
              pzip=$(find _all_artifacts -type f -name libpython.zip -print -quit || true)
              if [ -n "$pzip" ]; then mkdir -p _python_zip && cp "$pzip" _python_zip/libpython.zip; fi
            fi
          fi

      - name: Download Python debs
        uses: actions/download-artifact@v5
        continue-on-error: true
        with:
          name: ${{ inputs.python_debs_artifact }}
          path: _python_debs
          run-id: ${{ inputs.reuse_run_id }}
          github-token: ${{ github.token }}

      - name: Fallback download Python debs by pattern
        if: ${{ always() }}
        uses: actions/download-artifact@v5
        continue-on-error: true
        with:
          pattern: python-*
          path: _python_debs
          merge-multiple: true
          run-id: ${{ inputs.reuse_run_id }}
          github-token: ${{ github.token }}

      - name: Fallback download artifacts via gh (python)
        if: ${{ always() }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euxo pipefail
          mkdir -p _python_debs _python_zip
          if [ -z "$(ls -1 _python_debs 2>/dev/null || true)" ]; then
            gh run download ${{ inputs.reuse_run_id }} -n ${{ inputs.python_debs_artifact }} -D _python_debs || true
          fi
          if [ ! -f _python_zip/libpython.zip ]; then
            gh run download ${{ inputs.reuse_run_id }} -n ${{ inputs.python_artifact }} -D _python_zip || true
          fi

      - name: Extract debs and assemble jniLibs
        run: |
          set -euxo pipefail
          mkdir -p out/jniLibs/arm64-v8a out/tmp/aria2 out/tmp/python

          # Extract debs into temporary roots
          shopt -s nullglob
          for f in _aria2_debs/*.deb; do dpkg-deb -x "$f" out/tmp/aria2 || true; done
          for f in _python_debs/*.deb; do dpkg-deb -x "$f" out/tmp/python || true; done

          # Determine prefixes for aria2 and python
          aria2_prefix=""
          for p in out/tmp/aria2/data/youtubedl-android/usr out/tmp/aria2/data/data/com.termux/files/usr out/tmp/aria2/data/usr out/tmp/aria2/usr; do
            if [ -d "$p/lib" ]; then aria2_prefix="$p"; break; fi
          done
          python_prefix=""
          for p in out/tmp/python/data/youtubedl-android/usr out/tmp/python/data/data/com.termux/files/usr out/tmp/python/data/usr out/tmp/python/usr; do
            if [ -d "$p/lib" ]; then python_prefix="$p"; break; fi
          done

          # Stage .zip.so payloads, prefer repo outputfiles/, then staged zips, else build from debs
          aria2_zip_repo=$(find "$GITHUB_WORKSPACE/outputfiles" -type f -name libaria2c.zip -print -quit || true)
          if [ -n "$aria2_zip_repo" ]; then
            cp "$aria2_zip_repo" out/jniLibs/arm64-v8a/libaria2c.zip.so
          elif [ -f _aria2_zip/libaria2c.zip ]; then
            cp _aria2_zip/libaria2c.zip out/jniLibs/arm64-v8a/libaria2c.zip.so
          else
            if [ -z "$aria2_prefix" ]; then echo "::error::Could not find aria2 prefix to build zip"; exit 1; fi
            (cd "$(dirname "$aria2_prefix")" && zip --symlinks -r "$GITHUB_WORKSPACE/out/jniLibs/arm64-v8a/libaria2c.zip.so" "$(basename "$aria2_prefix")"/lib)
          fi

          python_zip_repo=$(find "$GITHUB_WORKSPACE/outputfiles" -type f -name libpython.zip -print -quit || true)
          if [ -n "$python_zip_repo" ]; then
            cp "$python_zip_repo" out/jniLibs/arm64-v8a/libpython.zip.so
          elif [ -f _python_zip/libpython.zip ]; then
            cp _python_zip/libpython.zip out/jniLibs/arm64-v8a/libpython.zip.so
          else
            if [ -z "$python_prefix" ]; then echo "::error::Could not find python prefix to build zip"; exit 1; fi
            (cd "$(dirname "$python_prefix")" && zip --symlinks -r "$GITHUB_WORKSPACE/out/jniLibs/arm64-v8a/libpython.zip.so" "$(basename "$python_prefix")"/lib)
          fi

          # Find aria2c executable and rename to libaria2c.so
          aria2c_path=$(find out/tmp/aria2 -type f -name aria2c | head -n1 || true)
          if [ -z "$aria2c_path" ]; then
            # Try from repo outputfiles if available
            repo_a2_so=$(find "$GITHUB_WORKSPACE/outputfiles" -type f -name libaria2c.so -print -quit || true)
            repo_a2_bin=$(find "$GITHUB_WORKSPACE/outputfiles" -type f -name aria2c -print -quit || true)
            if [ -n "$repo_a2_so" ]; then
              cp "$repo_a2_so" out/jniLibs/arm64-v8a/libaria2c.so
            elif [ -n "$repo_a2_bin" ]; then
              cp "$repo_a2_bin" out/jniLibs/arm64-v8a/libaria2c.so
            else
              echo "::error::aria2c not found in debs or repo outputfiles"; exit 1
            fi
          else
            cp "$aria2c_path" out/jniLibs/arm64-v8a/libaria2c.so
          fi

          # Find versioned libpythonX.Y.so and rename to libpython.so
          pyso_path=$(find out/tmp/python -type f -path "*/usr/lib/*" -name "libpython*.so" | head -n1 || true)
          if [ -z "$pyso_path" ]; then
            # Try from repo outputfiles if available
            repo_py_so=$(find "$GITHUB_WORKSPACE/outputfiles" -type f -name "libpython*.so" -print -quit || true)
            if [ -n "$repo_py_so" ]; then
              cp "$repo_py_so" out/jniLibs/arm64-v8a/libpython.so
            else
              echo "::error::libpython*.so not found in python debs or repo outputfiles"; exit 1
            fi
          else
            cp "$pyso_path" out/jniLibs/arm64-v8a/libpython.so
          fi

      - name: Verify 16KB PT_LOAD alignment
        run: |
          set -euo pipefail
          shopt -s nullglob
          real_sos=(out/jniLibs/arm64-v8a/*.so)
          status=0
          for f in "${real_sos[@]}"; do
            # Skip payload ZIPs named *.zip.so
            if [[ "$f" == *.zip.so ]]; then
              continue
            fi
            echo "Checking $f"
            if ! llvm-readobj --program-headers "$f" | grep -A3 "Type: PT_LOAD" | grep -q "Alignment: 16384"; then
              echo "::error::$f missing PT_LOAD Alignment: 16384"
              status=1
            fi
          done
          exit $status

      - name: Upload jniLibs artifact
        uses: actions/upload-artifact@v4
        with:
          name: jniLibs-arm64
          path: out/jniLibs/arm64-v8a
          if-no-files-found: error
          retention-days: 14


